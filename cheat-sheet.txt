-----------------------------------------------------------------------
------------------------Setting up-------------------------------------
-----------------------------------------------------------------------
1. dl node.js from https://nodejs.org/en (Current button)

] npm install -g @angular/cli@latest

2. create an angular project
] ng new my-awesome-app --no-strict --skip-tests

3. Once inside your project folder, install bootstrap locally inside your angular project folder..
] npm install --save bootstrap@3

4. Tell angular to use bootstrap

inside angular.json, find ... "styles" and add the path to the minified bootstrap css you installed

"styles": [
"node_modules/bootstrap/dist/css/bootstrap.min.css",
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------

https://angular.io/guide/lifecycle-hooks

-----------------------------------------------------------------------
----------------------closing the dropdown from anywhere---------------
-----------------------------------------------------------------------
If you want that a dropdown can also be closed by a click anywhere outside (which also means that a click on one dropdown closes any other one, btw.), replace the code of dropdown.directive.ts by this one (placing the listener not on the dropdown, but on the document):

import {Directive, ElementRef, HostBinding, HostListener} from '@angular/core';
 
@Directive({
  selector: '[appDropdown]'
})
export class DropdownDirective {
  @HostBinding('class.open') isOpen = false;
  @HostListener('document:click', ['$event']) toggleOpen(event: Event) {
    this.isOpen = this.elRef.nativeElement.contains(event.target) ? !this.isOpen : false;
  }
  constructor(private elRef: ElementRef) {}
}
-----------------------------------------------------------------------
-------------Alternative Injection Syntax------------------------------
-----------------------------------------------------------------------
Instead of injecting LoggingService like this:

@Component(...)
export class AccountComponent {
  // @Input() & @Output() code as shown in the previous lecture
 
  constructor(private loggingService: LoggingService) {}
}
you could inject it like this, by using the inject() function:

import { Component, Input, Output, inject } from '@angular/core'; // <- Add inject import
 
@Component(...)
export class AccountComponent {
  // @Input() & @Output() code as shown in the previous lecture
  private loggingService?: LoggingService; // <- must be added
 
  constructor() {
    this.loggingService = inject(LoggingService);
  }
}
It's totally up to you, which approach you prefer. In this course (and, as mentioned, in most projects), we'll use the constructor approach.
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------


-----------------------------------------------------------------------
-----------------A Different Way Of Injecting Services-----------------
-----------------------------------------------------------------------
If you're using Angular 6+ (check your package.json  to find out), you can provide application-wide services in a different way.

Instead of adding a service class to the providers[]  array in AppModule , you can set the following config in @Injectable() :

@Injectable({providedIn: 'root'})
export class MyService { ... }
This is exactly the same as:

export class MyService { ... }
and

import { MyService } from './path/to/my.service';
 
@NgModule({
    ...
    providers: [MyService]
})
export class AppModule { ... }
Using this syntax is completely optional, the traditional syntax (using providers[] ) will also work.

The "new syntax" does offer one advantage though: Services can be loaded lazily by Angular (behind the scenes) and redundant code can be removed automatically. This can lead to a better performance and loading speed - though this really only kicks in for bigger services and apps in general.
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------

-----------------------------------------------------------------------
---------Section 13--------Install RxJS--------------------------------
-----------------------------------------------------------------------
In order to follow along smoothly with the course examples, make sure you install RxJS v6 by running

npm install --save rxjs@6
In addition, also install the rxjs-compat package:

npm install --save rxjs-compat



-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------


-----------------------------------------------------------------------
---------extra learning------------------------------------------------
-----------------------------------------------------------------------

academind.com/learn/javascript

-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------


-----------------------------------------------------------------------
------------------Useful Resources & Links-----------------------------
-----------------------------------------------------------------------
Useful Resources:

Official Docs: https://rxjs-dev.firebaseapp.com/

RxJS Series: https://academind.com/learn/javascript/understanding-rxjs/

Updating to RxJS 6: https://academind.com/learn/javascript/rxjs-6-what-changed/

-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------

-----------------------------------------------------------------------
----------------------------------Forms--------------------------------
-----------------------------------------------------------------------

Angular has two flavours when it comes to Forms

Template Driven

&

Reactive


-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------


-----------------------------------------------------------------------
--------------Built-in Validators & Using HTML5 Validation-------------
-----------------------------------------------------------------------

Which Validators do ship with Angular? 

Check out the Validators class: https://angular.io/api/forms/Validators - these are all built-in validators, though that are the methods which actually get executed (and which you later can add when using the reactive approach).

For the template-driven approach, you need the directives. You can find out their names, by searching for "validator" in the official docs: https://angular.io/api?type=directive - everything marked with "D" is a directive and can be added to your template.

Additionally, you might also want to enable HTML5 validation (by default, Angular disables it). You can do so by adding the ngNativeValidate  to a control in your template.

-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------

-----------------------------------------------------------------------
------------------------Fixing a Bug-----------------------------------
-----------------------------------------------------------------------

In the next lecture, we'll add some code to access the controls of our form array:

*ngFor="let hobbyControl of signupForm.get('hobbies').controls; let i = index"

This code will fail as of the latest Angular version.

You can fix it easily though. Outsource the "get the controls" logic into a method of your component code (the .ts file):

getControls() {
  return (<FormArray>this.signupForm.get('hobbies')).controls;
}
In the template, you can then use:

*ngFor="let hobbyControl of getControls(); let i = index"

Alternatively, you can set up a getter and use an alternative type casting syntax:

get controls() {
  return (this.signupForm.get('hobbies') as FormArray).controls;
}
and then in the template:

*ngFor="let hobbyControl of controls; let i = index"

This adjustment is required due to the way TS works and Angular parses your templates (it doesn't understand TS there).

-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------

-----------------------------------------------------------------------
----set--Firebase--rules for read and write----------------------------
-----------------------------------------------------------------------
in firebase.. Realtime Database set Rules to

{
  "rules": {
    ".read": "auth != null",  // 2023-10-25
    ".write": "auth != null",  // 2023-10-25
  }
}

thereafter, got to Authentication and choose "Email/Password" Provider


-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------